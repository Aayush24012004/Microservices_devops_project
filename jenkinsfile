pipeline {
  agent any
  tools {
    jdk 'JDK17'
    nodejs 'NodeJS'
  }
  parameters {
    string(name: 'ECR_REPO_NAME',  defaultValue: 'microservices-project', description: 'Enter the ECR repository name')
    string(name: 'AWS_REGION',     defaultValue: 'us-east-1',            description: 'Enter your AWS region')
    string(name: 'AWS_ACCOUNT_ID', defaultValue: '',                      description: 'Enter your AWS Account ID')
  }

  environment {
    SCANNER_HOME = tool 'SonarQube Scanner'
  }

  options {
    buildDiscarder(logRotator(daysToKeepStr: '10'))
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        echo "Checked out branch ${env.BRANCH_NAME}"
      }
    }

    stage('SonarQube Analysis') {
      steps {
        withSonarQubeEnv('sonarqube-server') {
          sh """
            ${SCANNER_HOME}/bin/sonar-scanner \
              -Dsonar.projectName=microservicesProject \
              -Dsonar.projectKey=microservicesProject
          """
        }
      }
    }

    stage('Quality Gate') {
      steps {
        waitForQualityGate abortPipeline: false, credentialsId: 'sonarqube-token'
      }
    }

    stage('Trivy Scan') {
      steps {
        sh 'trivy fs . > trivy-scan-results.txt'
      }
    }

    stage('Docker Build') {
      steps {
        script {
          // find each service folder containing a Dockerfile
          def services = sh(
            script: "find src -maxdepth 2 -name Dockerfile | sed 's|/Dockerfile\$||'",
            returnStdout: true
          ).trim().split('\n')

          for (svcPath in services) {
            def svc = svcPath.tokenize('/').last()
            echo "â†’ Building Docker image for ${svc}"
            dir(svcPath) {
              sh "docker build -t ${params.ECR_REPO_NAME}-${svc}:${env.BUILD_NUMBER} ."
            }
          }
        }
      }
    }

    stage('Ensure ECR Repo') {
      steps {
        withCredentials([
          string(credentialsId: 'access-key', variable: 'AWS_ACCESS_KEY_ID'),
          string(credentialsId: 'secret-key', variable: 'AWS_SECRET_ACCESS_KEY')
        ]) {
          sh """
            aws --region ${params.AWS_REGION} \
              ecr describe-repositories --repository-names ${params.ECR_REPO_NAME}-auth-service || \
            aws --region ${params.AWS_REGION} \
              ecr create-repository --repository-name ${params.ECR_REPO_NAME}-auth-service

            aws --region ${params.AWS_REGION} \
              ecr describe-repositories --repository-names ${params.ECR_REPO_NAME}-user-service || \
            aws --region ${params.AWS_REGION} \
              ecr create-repository --repository-name ${params.ECR_REPO_NAME}-user-service

            aws --region ${params.AWS_REGION} \
              ecr describe-repositories --repository-names ${params.ECR_REPO_NAME}-product-service || \
            aws --region ${params.AWS_REGION} \
              ecr create-repository --repository-name ${params.ECR_REPO_NAME}-product-service

            aws --region ${params.AWS_REGION} \
              ecr describe-repositories --repository-names ${params.ECR_REPO_NAME}-frontend || \
            aws --region ${params.AWS_REGION} \
              ecr create-repository --repository-name ${params.ECR_REPO_NAME}-frontend
          """
        }
      }
    }

    stage('Login & Tag') {
      steps {
        withCredentials([
          string(credentialsId: 'access-key', variable: 'AWS_ACCESS_KEY_ID'),
          string(credentialsId: 'secret-key', variable: 'AWS_SECRET_ACCESS_KEY')
        ]) {
          script {
            sh "aws ecr get-login-password --region ${params.AWS_REGION} | docker login --username AWS --password-stdin ${params.AWS_ACCOUNT_ID}.dkr.ecr.${params.AWS_REGION}.amazonaws.com"

            def services = sh(
              script: "find src -maxdepth 2 -name Dockerfile | sed 's|/Dockerfile\$||'",
              returnStdout: true
            ).trim().split('\n')

            for (svcPath in services) {
              def svc = svcPath.tokenize('/').last()
              def localImage  = "${params.ECR_REPO_NAME}-${svc}:${env.BUILD_NUMBER}"
              def remoteRepo  = "${params.AWS_ACCOUNT_ID}.dkr.ecr.${params.AWS_REGION}.amazonaws.com/${params.ECR_REPO_NAME}-${svc}"
              sh """
                docker tag ${localImage} ${remoteRepo}:${env.BUILD_NUMBER}
                docker tag ${localImage} ${remoteRepo}:latest
              """
            }
          }
        }
      }
    }

    stage('Push to ECR') {
      steps {
        script {
          def services = sh(
            script: "find src -maxdepth 2 -name Dockerfile | sed 's|/Dockerfile\$||'",
            returnStdout: true
          ).trim().split('\n')

          for (svcPath in services) {
            def svc = svcPath.tokenize('/').last()
            def remoteRepo = "${params.AWS_ACCOUNT_ID}.dkr.ecr.${params.AWS_REGION}.amazonaws.com/${params.ECR_REPO_NAME}-${svc}"
            sh """
              docker push ${remoteRepo}:${env.BUILD_NUMBER}
              docker push ${remoteRepo}:latest
            """
          }
        }
      }
    }

    stage('Cleanup') {
      steps {
        script {
          def services = sh(
            script: "find src -maxdepth 2 -name Dockerfile | sed 's|/Dockerfile\$||'",
            returnStdout: true
          ).trim().split('\n')

          for (svcPath in services) {
            def svc = svcPath.tokenize('/').last()
            def remoteRepo = "${params.AWS_ACCOUNT_ID}.dkr.ecr.${params.AWS_REGION}.amazonaws.com/${params.ECR_REPO_NAME}-${svc}"
            sh """
              docker rmi ${remoteRepo}:${env.BUILD_NUMBER} || true
              docker rmi ${remoteRepo}:latest           || true
              docker rmi ${params.ECR_REPO_NAME}-${svc}:${env.BUILD_NUMBER} || true
            """
          }
        }
      }
    }
  }

  post {
  always {
    script {
      // 1) Compose the JSON payload
      def status = currentBuild.currentResult
      def payload = groovy.json.JsonOutput.toJson([
        text: "ðŸš€ *Build ${status}* for *${env.JOB_NAME} #${env.BUILD_NUMBER}*\nðŸ”— <${env.BUILD_URL}|View Build>"
      ])

      // 2) Print it to the console so you can see whatâ€™s being sent
      echo "Payload to send: ${payload}"

      // 3) Use a single-line sh command with proper quoting
      sh(
        script: "curl -X POST -H 'Content-Type: application/json' -d '${payload}' 'https://chat.googleapis.com/v1/spaces/AAQABmX28z8/messages?key=AIzaSyâ€¦&token=â€¦'",
        returnStatus: true
      )
    }
  }
}

